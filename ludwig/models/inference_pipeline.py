from typing import Any, Dict, List, TYPE_CHECKING, Union

import torch
from torch import nn

from ludwig.models.postprocess_module import PostprocessModule
from ludwig.models.predict_module import PredictModule
from ludwig.models.preprocess_module import PreprocessModule
from ludwig.utils import output_feature_utils

# Prevents circular import errors from typing.
if TYPE_CHECKING:
    from ludwig.models.ecd import ECD


class InferencePipelineModule(nn.Module):
    """Wraps preprocessing, model forward pass, and postprocessing modules into a single module.

    The purpose of the module is to be scripted into Torchscript for native serving. The nn.ModuleDict attributes of
    this module use keys generated by feature_utils.get_module_dict_key_from_name in order to prevent name collisions
    with keywords reserved by TorchScript.
    """

    def __init__(self, model: "ECD", config: Dict[str, Any], training_set_metadata: Dict[str, Any]):
        super().__init__()

        self.preprocess_module = torch.jit.script(PreprocessModule(config, training_set_metadata))
        self.predict_module = torch.jit.script(PredictModule(model))
        self.postprocess_module = torch.jit.script(PostprocessModule(config, training_set_metadata))

    def forward(self, inputs: Dict[str, Union[List[str], List[torch.Tensor], torch.Tensor]]):
        with torch.no_grad():
            preproc_outputs = self.preprocess_module(inputs)
            predictions = self.predict_module(preproc_outputs)
            postproc_outputs = self.postprocess_module(predictions)
            # Turn flat inputs into nested predictions per feature name
            final_outputs: Dict[str, Dict[str, Any]] = {}
            for postproc_key, tensor_values in postproc_outputs.items():
                feature_name = output_feature_utils.get_feature_name_from_concat_name(postproc_key)
                tensor_name = output_feature_utils.get_tensor_name_from_concat_name(postproc_key)
                outputs: Dict[str, Any] = {}
                if feature_name not in final_outputs:
                    final_outputs[feature_name] = outputs
                else:
                    outputs = final_outputs[feature_name]
                outputs[tensor_name] = tensor_values
            return final_outputs
