from typing import Any, Dict, List, TYPE_CHECKING, Union

import torch
from torch import nn

from ludwig.models.postprocess_module import PostprocessModule
from ludwig.models.predict_module import PredictModule
from ludwig.models.preprocess_module import PreprocessModule

# Prevents circular import errors from typing.
if TYPE_CHECKING:
    from ludwig.models.ecd import ECD


class InferencePipelineModule(nn.Module):
    """Wraps preprocessing, model forward pass, and postprocessing modules into a single module.

    The purpose of the module is to be scripted into Torchscript for native serving. The nn.ModuleDict attributes of
    this module use keys generated by feature_utils.get_module_dict_key_from_name in order to prevent name collisions
    with keywords reserved by TorchScript.
    """

    def __init__(self, model: "ECD", config: Dict[str, Any], training_set_metadata: Dict[str, Any]):
        super().__init__()

        self.preprocess_module = torch.jit.script(PreprocessModule(config, training_set_metadata))
        self.predict_module = torch.jit.script(PredictModule(model))
        self.postprocess_module = torch.jit.script(PostprocessModule(config, training_set_metadata))

    def forward(self, inputs: Dict[str, Union[List[str], List[torch.Tensor], torch.Tensor]]):
        with torch.no_grad():
            preproc_outputs = self.preprocess_module(inputs)
            predictions = self.predict_module(preproc_outputs)
            postproc_outputs = self.postprocess_module(predictions)
            return postproc_outputs
